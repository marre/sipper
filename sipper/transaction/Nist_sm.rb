# DO NOT EDIT.
# generated by smc (http://smc.sourceforge.net/)
# from file : Nist.sm

require 'statemap'

class NistState < Statemap::State

    def Entry(fsm) end

    def Exit(fsm) end

    def cancel_with_no_st(fsm, r)
        Default(fsm)
    end

    def cancel_with_st(fsm, r)
        Default(fsm)
    end

    def final(fsm, r)
        Default(fsm)
    end

    def provisional(fsm, r)
        Default(fsm)
    end

    def request(fsm)
        Default(fsm)
    end

    def timer_J(fsm)
        Default(fsm)
    end

    def transport_err(fsm)
        Default(fsm)
    end

    def Default(fsm)
        msg = "\nState: " + fsm.getState.getName +
            "\nTransition: " + fsm.getTransition + "\n"
        raise Statemap::TransitionUndefinedException, msg
    end

end

class NistMap_Default < NistState

end

class NistMap_Initial < NistMap_Default

    def cancel_with_no_st(fsm, r)
        ctxt = fsm.getOwner
        fsm.getState.Exit(fsm)
        fsm.clearState
        begin
            ctxt.__send_final_response(r)
            ctxt.__consume_msg(false)
        ensure
            fsm.setState(NistMap::Completed)
            fsm.getState.Entry(fsm)
        end
    end

    def cancel_with_st(fsm, r)
        ctxt = fsm.getOwner
        fsm.getState.Exit(fsm)
        fsm.clearState
        begin
            ctxt.__send_final_response(r)
            ctxt.__consume_msg(true)
        ensure
            fsm.setState(NistMap::Completed)
            fsm.getState.Entry(fsm)
        end
    end

    def request(fsm)
        ctxt = fsm.getOwner
        fsm.getState.Exit(fsm)
        fsm.clearState
        begin
            ctxt.__consume_msg(true)
        ensure
            fsm.setState(NistMap::Trying)
            fsm.getState.Entry(fsm)
        end
    end

end

class NistMap_Trying < NistMap_Default

    def final(fsm, r)
        ctxt = fsm.getOwner
        fsm.getState.Exit(fsm)
        fsm.clearState
        begin
            ctxt.__send_final_response(r)
        ensure
            fsm.setState(NistMap::Completed)
            fsm.getState.Entry(fsm)
        end
    end

    def provisional(fsm, r)
        ctxt = fsm.getOwner
        fsm.getState.Exit(fsm)
        fsm.clearState
        begin
            ctxt.__send_provisional_response(r)
        ensure
            fsm.setState(NistMap::Proceeding)
            fsm.getState.Entry(fsm)
        end
    end

    def request(fsm)
        ctxt = fsm.getOwner
        endState = fsm.getState
        fsm.clearState
        begin
            ctxt.__consume_msg(false)
        ensure
            fsm.setState(endState)
        end
    end

    def transport_err(fsm)
        ctxt = fsm.getOwner
        fsm.getState.Exit(fsm)
        fsm.clearState
        begin
            ctxt.__transport_err()
        ensure
            fsm.setState(NistMap::Terminated)
            fsm.getState.Entry(fsm)
        end
    end

end

class NistMap_Proceeding < NistMap_Default

    def final(fsm, r)
        ctxt = fsm.getOwner
        fsm.getState.Exit(fsm)
        fsm.clearState
        begin
            ctxt.__send_final_response(r)
        ensure
            fsm.setState(NistMap::Completed)
            fsm.getState.Entry(fsm)
        end
    end

    def provisional(fsm, r)
        ctxt = fsm.getOwner
        endState = fsm.getState
        fsm.clearState
        begin
            ctxt.__send_provisional_response(r)
        ensure
            fsm.setState(endState)
        end
    end

    def request(fsm)
        ctxt = fsm.getOwner
        endState = fsm.getState
        fsm.clearState
        begin
            ctxt.__send_last_response()
            ctxt.__consume_msg(false)
        ensure
            fsm.setState(endState)
        end
    end

    def transport_err(fsm)
        ctxt = fsm.getOwner
        fsm.getState.Exit(fsm)
        fsm.clearState
        begin
            ctxt.__transport_err()
        ensure
            fsm.setState(NistMap::Terminated)
            fsm.getState.Entry(fsm)
        end
    end

end

class NistMap_Completed < NistMap_Default

    def Entry(fsm)
        ctxt = fsm.getOwner
        ctxt.__start_J()
    end

    def Exit(fsm)
        ctxt = fsm.getOwner
        ctxt.__cancel_J()
    end

    def cancel_with_no_st(fsm, r)
        ctxt = fsm.getOwner
        endState = fsm.getState
        fsm.clearState
        begin
            ctxt.__send_last_response()
            ctxt.__consume_msg(false)
        ensure
            fsm.setState(endState)
        end
    end

    def cancel_with_st(fsm, r)
        ctxt = fsm.getOwner
        endState = fsm.getState
        fsm.clearState
        begin
            ctxt.__send_last_response()
            ctxt.__consume_msg(false)
        ensure
            fsm.setState(endState)
        end
    end

    def final(fsm, r)
    end

    def request(fsm)
        ctxt = fsm.getOwner
        endState = fsm.getState
        fsm.clearState
        begin
            ctxt.__send_last_response()
            ctxt.__consume_msg(false)
        ensure
            fsm.setState(endState)
        end
    end

    def timer_J(fsm)
        ctxt = fsm.getOwner
        fsm.getState.Exit(fsm)
        fsm.clearState
        begin
            ctxt.__timeout()
        ensure
            fsm.setState(NistMap::Terminated)
            fsm.getState.Entry(fsm)
        end
    end

    def transport_err(fsm)
        ctxt = fsm.getOwner
        fsm.getState.Exit(fsm)
        fsm.clearState
        begin
            ctxt.__transport_err()
        ensure
            fsm.setState(NistMap::Terminated)
            fsm.getState.Entry(fsm)
        end
    end

end

class NistMap_Terminated < NistMap_Default

    def Entry(fsm)
        ctxt = fsm.getOwner
        ctxt.__cleanup()
    end

end

module NistMap

    Initial = NistMap_Initial::new('NistMap.Initial', 0).freeze
    Trying = NistMap_Trying::new('NistMap.Trying', 1).freeze
    Proceeding = NistMap_Proceeding::new('NistMap.Proceeding', 2).freeze
    Completed = NistMap_Completed::new('NistMap.Completed', 3).freeze
    Terminated = NistMap_Terminated::new('NistMap.Terminated', 4).freeze
    Default = NistMap_Default::new('NistMap.Default', -1).freeze

end

class Nist_sm < Statemap::FSMContext

    def initialize(owner)
        super()
        @_owner = owner
        setState(NistMap::Initial)
        NistMap::Initial.Entry(self)
    end

    def cancel_with_no_st(*arglist)
        @_transition = 'cancel_with_no_st'
        getState.cancel_with_no_st(self, *arglist)
        @_transition = nil
    end

    def cancel_with_st(*arglist)
        @_transition = 'cancel_with_st'
        getState.cancel_with_st(self, *arglist)
        @_transition = nil
    end

    def final(*arglist)
        @_transition = 'final'
        getState.final(self, *arglist)
        @_transition = nil
    end

    def provisional(*arglist)
        @_transition = 'provisional'
        getState.provisional(self, *arglist)
        @_transition = nil
    end

    def request()
        @_transition = 'request'
        getState.request(self)
        @_transition = nil
    end

    def timer_J()
        @_transition = 'timer_J'
        getState.timer_J(self)
        @_transition = nil
    end

    def transport_err()
        @_transition = 'transport_err'
        getState.transport_err(self)
        @_transition = nil
    end

    def getState()
        if @_state.nil? then
            raise Statemap::StateUndefinedException
        end
        return @_state
    end

    def getOwner()
        return @_owner
    end

end
