# DO NOT EDIT.
# generated by smc (http://smc.sourceforge.net/)
# from file : Ist.sm

require 'statemap'

class IstState < Statemap::State

    def Entry(fsm) end

    def Exit(fsm) end

    def ack(fsm)
        Default(fsm)
    end

    def cancel(fsm)
        Default(fsm)
    end

    def invite(fsm)
        Default(fsm)
    end

    def non_success_final(fsm, r)
        Default(fsm)
    end

    def provisional(fsm, r)
        Default(fsm)
    end

    def success_final(fsm, r)
        Default(fsm)
    end

    def timer_G(fsm, t)
        Default(fsm)
    end

    def timer_H(fsm)
        Default(fsm)
    end

    def timer_I(fsm)
        Default(fsm)
    end

    def timer_Z(fsm)
        Default(fsm)
    end

    def transport_err(fsm)
        Default(fsm)
    end

    def Default(fsm)
        if fsm.getDebugFlag then
            fsm.getDebugStream.write("TRANSITION   : Default\n")
        end
        msg = "\nState: " + fsm.getState.getName +
            "\nTransition: " + fsm.getTransition + "\n"
        raise Statemap::TransitionUndefinedException, msg
    end

end

class IstMap_Default < IstState

end

class IstMap_Initial < IstMap_Default

    def invite(fsm)
        ctxt = fsm.getOwner
        if fsm.getDebugFlag then
            fsm.getDebugStream.write("TRANSITION   : IstMap::Initial.invite\n")
        end
        fsm.getState.Exit(fsm)
        fsm.clearState
        begin
            ctxt.__send_trying()
            ctxt.__consume_msg(true)
        rescue RuntimeError => e
            fsm.getDebugStream.write e
        ensure
            fsm.setState(IstMap::Proceeding)
            fsm.getState.Entry(fsm)
        end
    end

    def transport_err(fsm)
        ctxt = fsm.getOwner
        if fsm.getDebugFlag then
            fsm.getDebugStream.write("TRANSITION   : IstMap::Initial.transport_err\n")
        end
        fsm.getState.Exit(fsm)
        fsm.clearState
        begin
            ctxt.__transport_err()
        rescue RuntimeError => e
            fsm.getDebugStream.write e
        ensure
            fsm.setState(IstMap::Terminated)
            fsm.getState.Entry(fsm)
        end
    end

end

class IstMap_Proceeding < IstMap_Default

    def cancel(fsm)
        ctxt = fsm.getOwner
        if fsm.getDebugFlag then
            fsm.getDebugStream.write("TRANSITION   : IstMap::Proceeding.cancel\n")
        end
        fsm.getState.Exit(fsm)
        fsm.clearState
        begin
            ctxt.__create_and_send_487()
            ctxt.__consume_msg(true)
        rescue RuntimeError => e
            fsm.getDebugStream.write e
        ensure
            fsm.setState(IstMap::Completed)
            fsm.getState.Entry(fsm)
        end
    end

    def invite(fsm)
        ctxt = fsm.getOwner
        if fsm.getDebugFlag then
            fsm.getDebugStream.write("TRANSITION   : IstMap::Proceeding.invite\n")
        end
        endState = fsm.getState
        fsm.clearState
        begin
            ctxt.__send_last_response()
            ctxt.__consume_msg(false)
        rescue RuntimeError => e
            fsm.getDebugStream.write e
        ensure
            fsm.setState(endState)
        end
    end

    def non_success_final(fsm, r)
        ctxt = fsm.getOwner
        if fsm.getDebugFlag then
            fsm.getDebugStream.write("TRANSITION   : IstMap::Proceeding.non_success_final(r)\n")
        end
        fsm.getState.Exit(fsm)
        fsm.clearState
        begin
            ctxt.__send_non_success_final_response(r)
        rescue RuntimeError => e
            fsm.getDebugStream.write e
        ensure
            fsm.setState(IstMap::Completed)
            fsm.getState.Entry(fsm)
        end
    end

    def provisional(fsm, r)
        ctxt = fsm.getOwner
        if fsm.getDebugFlag then
            fsm.getDebugStream.write("TRANSITION   : IstMap::Proceeding.provisional(r)\n")
        end
        endState = fsm.getState
        fsm.clearState
        begin
            ctxt.__send_provisional_response(r)
        rescue RuntimeError => e
            fsm.getDebugStream.write e
        ensure
            fsm.setState(endState)
        end
    end

    def success_final(fsm, r)
        ctxt = fsm.getOwner
        if fsm.getDebugFlag then
            fsm.getDebugStream.write("TRANSITION   : IstMap::Proceeding.success_final(r)\n")
        end
        fsm.getState.Exit(fsm)
        fsm.clearState
        begin
            ctxt.__send_success_response(r)
        rescue RuntimeError => e
            fsm.getDebugStream.write e
        ensure
            fsm.setState(IstMap::Finished)
            fsm.getState.Entry(fsm)
        end
    end

    def transport_err(fsm)
        ctxt = fsm.getOwner
        if fsm.getDebugFlag then
            fsm.getDebugStream.write("TRANSITION   : IstMap::Proceeding.transport_err\n")
        end
        fsm.getState.Exit(fsm)
        fsm.clearState
        begin
            ctxt.__transport_err()
        rescue RuntimeError => e
            fsm.getDebugStream.write e
        ensure
            fsm.setState(IstMap::Terminated)
            fsm.getState.Entry(fsm)
        end
    end

end

class IstMap_Completed < IstMap_Default

    def Entry(fsm)
        ctxt = fsm.getOwner
        ctxt.__start_H()
        ctxt.__start_G()
    end

    def Exit(fsm)
        ctxt = fsm.getOwner
        ctxt.__cancel_H()
        ctxt.__cancel_G()
    end

    def ack(fsm)
        ctxt = fsm.getOwner
        if fsm.getDebugFlag then
            fsm.getDebugStream.write("TRANSITION   : IstMap::Completed.ack\n")
        end
        fsm.getState.Exit(fsm)
        fsm.clearState
        begin
            ctxt.__consume_msg(true)
        rescue RuntimeError => e
            fsm.getDebugStream.write e
        ensure
            fsm.setState(IstMap::Confirmed)
            fsm.getState.Entry(fsm)
        end
    end

    def cancel(fsm)
        ctxt = fsm.getOwner
        if fsm.getDebugFlag then
            fsm.getDebugStream.write("TRANSITION   : IstMap::Completed.cancel\n")
        end
        endState = fsm.getState
        fsm.clearState
        begin
            ctxt.__consume_msg(true)
        rescue RuntimeError => e
            fsm.getDebugStream.write e
        ensure
            fsm.setState(endState)
        end
    end

    def invite(fsm)
        ctxt = fsm.getOwner
        if fsm.getDebugFlag then
            fsm.getDebugStream.write("TRANSITION   : IstMap::Completed.invite\n")
        end
        endState = fsm.getState
        fsm.clearState
        begin
            ctxt.__send_last_response()
            ctxt.__consume_msg(false)
        rescue RuntimeError => e
            fsm.getDebugStream.write e
        ensure
            fsm.setState(endState)
        end
    end

    def timer_G(fsm, t)
        ctxt = fsm.getOwner
        if fsm.getDebugFlag then
            fsm.getDebugStream.write("TRANSITION   : IstMap::Completed.timer_G(t)\n")
        end
        endState = fsm.getState
        fsm.clearState
        begin
            ctxt.__send_last_response()
            ctxt.__reset_G(t)
        rescue RuntimeError => e
            fsm.getDebugStream.write e
        ensure
            fsm.setState(endState)
        end
    end

    def timer_H(fsm)
        ctxt = fsm.getOwner
        if fsm.getDebugFlag then
            fsm.getDebugStream.write("TRANSITION   : IstMap::Completed.timer_H\n")
        end
        fsm.getState.Exit(fsm)
        fsm.clearState
        begin
            ctxt.__timeout()
        rescue RuntimeError => e
            fsm.getDebugStream.write e
        ensure
            fsm.setState(IstMap::Terminated)
            fsm.getState.Entry(fsm)
        end
    end

    def transport_err(fsm)
        ctxt = fsm.getOwner
        if fsm.getDebugFlag then
            fsm.getDebugStream.write("TRANSITION   : IstMap::Completed.transport_err\n")
        end
        fsm.getState.Exit(fsm)
        fsm.clearState
        begin
            ctxt.__transport_err()
        rescue RuntimeError => e
            fsm.getDebugStream.write e
        ensure
            fsm.setState(IstMap::Terminated)
            fsm.getState.Entry(fsm)
        end
    end

end

class IstMap_Confirmed < IstMap_Default

    def Entry(fsm)
        ctxt = fsm.getOwner
        ctxt.__start_I()
    end

    def ack(fsm)
        ctxt = fsm.getOwner
        if fsm.getDebugFlag then
            fsm.getDebugStream.write("TRANSITION   : IstMap::Confirmed.ack\n")
        end
        endState = fsm.getState
        fsm.clearState
        begin
            ctxt.__consume_msg(true)
        rescue RuntimeError => e
            fsm.getDebugStream.write e
        ensure
            fsm.setState(endState)
        end
    end

    def cancel(fsm)
        ctxt = fsm.getOwner
        if fsm.getDebugFlag then
            fsm.getDebugStream.write("TRANSITION   : IstMap::Confirmed.cancel\n")
        end
        endState = fsm.getState
        fsm.clearState
        begin
            ctxt.__consume_msg(true)
        rescue RuntimeError => e
            fsm.getDebugStream.write e
        ensure
            fsm.setState(endState)
        end
    end

    def invite(fsm)
        ctxt = fsm.getOwner
        if fsm.getDebugFlag then
            fsm.getDebugStream.write("TRANSITION   : IstMap::Confirmed.invite\n")
        end
        endState = fsm.getState
        fsm.clearState
        begin
            ctxt.__send_last_response()
            ctxt.__consume_msg(false)
        rescue RuntimeError => e
            fsm.getDebugStream.write e
        ensure
            fsm.setState(endState)
        end
    end

    def timer_I(fsm)
        ctxt = fsm.getOwner
        if fsm.getDebugFlag then
            fsm.getDebugStream.write("TRANSITION   : IstMap::Confirmed.timer_I\n")
        end
        fsm.getState.Exit(fsm)
        fsm.clearState
        begin
            ctxt.__timeout()
        rescue RuntimeError => e
            fsm.getDebugStream.write e
        ensure
            fsm.setState(IstMap::Terminated)
            fsm.getState.Entry(fsm)
        end
    end

end

class IstMap_Finished < IstMap_Default

    def Entry(fsm)
        ctxt = fsm.getOwner
        ctxt.__start_Z()
    end

    def cancel(fsm)
        ctxt = fsm.getOwner
        if fsm.getDebugFlag then
            fsm.getDebugStream.write("TRANSITION   : IstMap::Finished.cancel\n")
        end
        endState = fsm.getState
        fsm.clearState
        begin
            ctxt.__consume_msg(true)
        rescue RuntimeError => e
            fsm.getDebugStream.write e
        ensure
            fsm.setState(endState)
        end
    end

    def invite(fsm)
        ctxt = fsm.getOwner
        if fsm.getDebugFlag then
            fsm.getDebugStream.write("TRANSITION   : IstMap::Finished.invite\n")
        end
        endState = fsm.getState
        fsm.clearState
        begin
            ctxt.__consume_msg(false)
        rescue RuntimeError => e
            fsm.getDebugStream.write e
        ensure
            fsm.setState(endState)
        end
    end

    def timer_Z(fsm)
        if fsm.getDebugFlag then
            fsm.getDebugStream.write("TRANSITION   : IstMap::Finished.timer_Z\n")
        end
        fsm.getState.Exit(fsm)
        fsm.setState(IstMap::Terminated)
        fsm.getState.Entry(fsm)
    end

end

class IstMap_Terminated < IstMap_Default

    def Entry(fsm)
        ctxt = fsm.getOwner
        ctxt.__cleanup()
    end

end

module IstMap

    Initial = IstMap_Initial::new('IstMap.Initial', 0).freeze
    Proceeding = IstMap_Proceeding::new('IstMap.Proceeding', 1).freeze
    Completed = IstMap_Completed::new('IstMap.Completed', 2).freeze
    Confirmed = IstMap_Confirmed::new('IstMap.Confirmed', 3).freeze
    Finished = IstMap_Finished::new('IstMap.Finished', 4).freeze
    Terminated = IstMap_Terminated::new('IstMap.Terminated', 5).freeze
    Default = IstMap_Default::new('IstMap.Default', -1).freeze

end

class Ist_sm < Statemap::FSMContext

    def initialize(owner)
        super()
        @_owner = owner
        setState(IstMap::Initial)
        IstMap::Initial.Entry(self)
    end

    def ack()
        @_transition = 'ack'
        getState.ack(self)
        @_transition = nil
    end

    def cancel()
        @_transition = 'cancel'
        getState.cancel(self)
        @_transition = nil
    end

    def invite()
        @_transition = 'invite'
        getState.invite(self)
        @_transition = nil
    end

    def non_success_final(*arglist)
        @_transition = 'non_success_final'
        getState.non_success_final(self, *arglist)
        @_transition = nil
    end

    def provisional(*arglist)
        @_transition = 'provisional'
        getState.provisional(self, *arglist)
        @_transition = nil
    end

    def success_final(*arglist)
        @_transition = 'success_final'
        getState.success_final(self, *arglist)
        @_transition = nil
    end

    def timer_G(*arglist)
        @_transition = 'timer_G'
        getState.timer_G(self, *arglist)
        @_transition = nil
    end

    def timer_H()
        @_transition = 'timer_H'
        getState.timer_H(self)
        @_transition = nil
    end

    def timer_I()
        @_transition = 'timer_I'
        getState.timer_I(self)
        @_transition = nil
    end

    def timer_Z()
        @_transition = 'timer_Z'
        getState.timer_Z(self)
        @_transition = nil
    end

    def transport_err()
        @_transition = 'transport_err'
        getState.transport_err(self)
        @_transition = nil
    end

    def getState()
        if @_state.nil? then
            raise Statemap::StateUndefinedException
        end
        return @_state
    end

    def getOwner()
        return @_owner
    end

end
