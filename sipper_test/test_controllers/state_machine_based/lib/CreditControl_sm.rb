# DO NOT EDIT.
# generated by smc (http://smc.sourceforge.net/)
# from file : CreditControl.sm

require 'statemap'

class SipCreditControlState < Statemap::State

    def Entry(fsm) end

    def Exit(fsm) end

    def bye(fsm, s)
        Default(fsm)
    end

    def error(fsm, s)
        Default(fsm)
    end

    def invite(fsm)
        Default(fsm)
    end

    def message(fsm, s)
        Default(fsm)
    end

    def provisional(fsm)
        Default(fsm)
    end

    def success(fsm)
        Default(fsm)
    end

    def Default(fsm)
        msg = "\nState: " + fsm.getState.getName +
            "\nTransition: " + fsm.getTransition + "\n"
        raise Statemap::TransitionUndefinedException, msg
    end

end

class MessageMap_Default < SipCreditControlState

end

class MessageMap_Initial < MessageMap_Default

    def invite(fsm)
        fsm.getState.Exit(fsm)
        fsm.setState(MessageMap::Connecting)
        fsm.getState.Entry(fsm)
    end

end

class MessageMap_Connecting < MessageMap_Default

    def error(fsm, s)
        ctxt = fsm.getOwner
        fsm.getState.Exit(fsm)
        fsm.clearState
        begin
            ctxt.cleanup(s)
        ensure
            fsm.setState(MessageMap::Terminated)
            fsm.getState.Entry(fsm)
        end
    end

    def provisional(fsm)
    end

    def success(fsm)
        fsm.getState.Exit(fsm)
        fsm.setState(MessageMap::Connected)
        fsm.getState.Entry(fsm)
    end

end

class MessageMap_Connected < MessageMap_Default

    def bye(fsm, s)
        ctxt = fsm.getOwner
        fsm.getState.Exit(fsm)
        fsm.clearState
        begin
            ctxt.send_bye(s)
            ctxt.cleanup(s)
        ensure
            fsm.setState(MessageMap::Terminated)
            fsm.getState.Entry(fsm)
        end
    end

    def message(fsm, s)
        ctxt = fsm.getOwner
        if ctxt.check_credit(s) then
            endState = fsm.getState
            fsm.clearState
            begin
                ctxt.send_success(s)
            ensure
                fsm.setState(endState)
            end
        else
            fsm.getState.Exit(fsm)
            fsm.clearState
            begin
                ctxt.send_bye(s)
                ctxt.cleanup(s)
            ensure
                fsm.setState(MessageMap::Terminated)
                fsm.getState.Entry(fsm)
            end
        end
    end

end

class MessageMap_Terminated < MessageMap_Default

end

module MessageMap

    Initial = MessageMap_Initial::new('MessageMap.Initial', 0).freeze
    Connecting = MessageMap_Connecting::new('MessageMap.Connecting', 1).freeze
    Connected = MessageMap_Connected::new('MessageMap.Connected', 2).freeze
    Terminated = MessageMap_Terminated::new('MessageMap.Terminated', 3).freeze
    Default = MessageMap_Default::new('MessageMap.Default', -1).freeze

end

class SipCreditControl_sm < Statemap::FSMContext

    def initialize(owner)
        super()
        @_owner = owner
        setState(MessageMap::Initial)
        MessageMap::Initial.Entry(self)
    end

    def bye(*arglist)
        @_transition = 'bye'
        getState.bye(self, *arglist)
        @_transition = nil
    end

    def error(*arglist)
        @_transition = 'error'
        getState.error(self, *arglist)
        @_transition = nil
    end

    def invite()
        @_transition = 'invite'
        getState.invite(self)
        @_transition = nil
    end

    def message(*arglist)
        @_transition = 'message'
        getState.message(self, *arglist)
        @_transition = nil
    end

    def provisional()
        @_transition = 'provisional'
        getState.provisional(self)
        @_transition = nil
    end

    def success()
        @_transition = 'success'
        getState.success(self)
        @_transition = nil
    end

    def getState()
        if @_state.nil? then
            raise Statemap::StateUndefinedException
        end
        return @_state
    end

    def getOwner()
        return @_owner
    end

end
