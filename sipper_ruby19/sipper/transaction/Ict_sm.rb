# DO NOT EDIT.
# generated by smc (http://smc.sourceforge.net/)
# from file : Ict.sm

require 'statemap'

class IctState < Statemap::State

    def Entry(fsm) end

    def Exit(fsm) end

    def cancel_sent(fsm)
        Default(fsm)
    end

    def invite(fsm)
        Default(fsm)
    end

    def non_success_final(fsm)
        Default(fsm)
    end

    def provisional(fsm)
        Default(fsm)
    end

    def success_final(fsm)
        Default(fsm)
    end

    def timer_A(fsm, t)
        Default(fsm)
    end

    def timer_B(fsm)
        Default(fsm)
    end

    def timer_D(fsm)
        Default(fsm)
    end

    def timer_Y(fsm)
        Default(fsm)
    end

    def transport_err(fsm)
        Default(fsm)
    end

    def Default(fsm)
        msg = "\nState: " + fsm.getState.getName +
            "\nTransition: " + fsm.getTransition + "\n"
        raise Statemap::TransitionUndefinedException, msg
    end

end

class IctMap_Default < IctState

end

class IctMap_Initial < IctMap_Default

    def invite(fsm)
        ctxt = fsm.getOwner
        fsm.getState.Exit(fsm)
        fsm.clearState
        begin
            ctxt.__send_invite()
            ctxt.__start_A()
            ctxt.__start_B()
        ensure
            fsm.setState(IctMap::Calling)
            fsm.getState.Entry(fsm)
        end
    end

    def transport_err(fsm)
        ctxt = fsm.getOwner
        fsm.getState.Exit(fsm)
        fsm.clearState
        begin
            ctxt.__transport_err()
        ensure
            fsm.setState(IctMap::Terminated)
            fsm.getState.Entry(fsm)
        end
    end

end

class IctMap_Calling < IctMap_Default

    def Exit(fsm)
        ctxt = fsm.getOwner
        ctxt.__cancel_A()
        ctxt.__cancel_B()
    end

    def cancel_sent(fsm)
        ctxt = fsm.getOwner
        endState = fsm.getState
        fsm.clearState
        begin
            ctxt.__start_Y()
        ensure
            fsm.setState(endState)
        end
    end

    def non_success_final(fsm)
        ctxt = fsm.getOwner
        fsm.getState.Exit(fsm)
        fsm.clearState
        begin
            ctxt.__create_ack()
            ctxt.__send_ack()
            ctxt.__cancel_Y()
            ctxt.__consume_msg(true)
        ensure
            fsm.setState(IctMap::Completed)
            fsm.getState.Entry(fsm)
        end
    end

    def provisional(fsm)
        ctxt = fsm.getOwner
        fsm.getState.Exit(fsm)
        fsm.clearState
        begin
            ctxt.__consume_msg(true)
        ensure
            fsm.setState(IctMap::Proceeding)
            fsm.getState.Entry(fsm)
        end
    end

    def success_final(fsm)
        ctxt = fsm.getOwner
        fsm.getState.Exit(fsm)
        fsm.clearState
        begin
            ctxt.__cancel_Y()
            ctxt.__consume_msg(true)
        ensure
            fsm.setState(IctMap::Terminated)
            fsm.getState.Entry(fsm)
        end
    end

    def timer_A(fsm, t)
        ctxt = fsm.getOwner
        endState = fsm.getState
        fsm.clearState
        begin
            ctxt.__send_invite()
            ctxt.__reset_A(t)
        ensure
            fsm.setState(endState)
        end
    end

    def timer_B(fsm)
        ctxt = fsm.getOwner
        fsm.getState.Exit(fsm)
        fsm.clearState
        begin
            ctxt.__timeout()
        ensure
            fsm.setState(IctMap::Terminated)
            fsm.getState.Entry(fsm)
        end
    end

    def timer_Y(fsm)
        ctxt = fsm.getOwner
        fsm.getState.Exit(fsm)
        fsm.clearState
        begin
            ctxt.__timeout()
        ensure
            fsm.setState(IctMap::Terminated)
            fsm.getState.Entry(fsm)
        end
    end

    def transport_err(fsm)
        ctxt = fsm.getOwner
        fsm.getState.Exit(fsm)
        fsm.clearState
        begin
            ctxt.__transport_err()
        ensure
            fsm.setState(IctMap::Terminated)
            fsm.getState.Entry(fsm)
        end
    end

end

class IctMap_Proceeding < IctMap_Default

    def Exit(fsm)
        ctxt = fsm.getOwner
        ctxt.__cancel_Y()
    end

    def cancel_sent(fsm)
        ctxt = fsm.getOwner
        endState = fsm.getState
        fsm.clearState
        begin
            ctxt.__start_Y()
        ensure
            fsm.setState(endState)
        end
    end

    def non_success_final(fsm)
        ctxt = fsm.getOwner
        fsm.getState.Exit(fsm)
        fsm.clearState
        begin
            ctxt.__create_ack()
            ctxt.__send_ack()
            ctxt.__consume_msg(true)
        ensure
            fsm.setState(IctMap::Completed)
            fsm.getState.Entry(fsm)
        end
    end

    def provisional(fsm)
        ctxt = fsm.getOwner
        endState = fsm.getState
        fsm.clearState
        begin
            ctxt.__consume_msg(true)
        ensure
            fsm.setState(endState)
        end
    end

    def success_final(fsm)
        ctxt = fsm.getOwner
        fsm.getState.Exit(fsm)
        fsm.clearState
        begin
            ctxt.__consume_msg(true)
        ensure
            fsm.setState(IctMap::Terminated)
            fsm.getState.Entry(fsm)
        end
    end

    def timer_Y(fsm)
        ctxt = fsm.getOwner
        fsm.getState.Exit(fsm)
        fsm.clearState
        begin
            ctxt.__timeout()
        ensure
            fsm.setState(IctMap::Terminated)
            fsm.getState.Entry(fsm)
        end
    end

    def transport_err(fsm)
        ctxt = fsm.getOwner
        fsm.getState.Exit(fsm)
        fsm.clearState
        begin
            ctxt.__transport_err()
        ensure
            fsm.setState(IctMap::Terminated)
            fsm.getState.Entry(fsm)
        end
    end

end

class IctMap_Completed < IctMap_Default

    def Entry(fsm)
        ctxt = fsm.getOwner
        ctxt.__start_D()
    end

    def cancel_sent(fsm)
    end

    def non_success_final(fsm)
        ctxt = fsm.getOwner
        endState = fsm.getState
        fsm.clearState
        begin
            ctxt.__send_ack()
            ctxt.__consume_msg(false)
        ensure
            fsm.setState(endState)
        end
    end

    def timer_D(fsm)
        fsm.getState.Exit(fsm)
        fsm.setState(IctMap::Terminated)
        fsm.getState.Entry(fsm)
    end

    def transport_err(fsm)
        ctxt = fsm.getOwner
        fsm.getState.Exit(fsm)
        fsm.clearState
        begin
            ctxt.__transport_err()
        ensure
            fsm.setState(IctMap::Terminated)
            fsm.getState.Entry(fsm)
        end
    end

end

class IctMap_Terminated < IctMap_Default

    def Entry(fsm)
        ctxt = fsm.getOwner
        ctxt.__cleanup()
    end

    def cancel_sent(fsm)
    end

end

module IctMap

    Initial = IctMap_Initial::new('IctMap.Initial', 0).freeze
    Calling = IctMap_Calling::new('IctMap.Calling', 1).freeze
    Proceeding = IctMap_Proceeding::new('IctMap.Proceeding', 2).freeze
    Completed = IctMap_Completed::new('IctMap.Completed', 3).freeze
    Terminated = IctMap_Terminated::new('IctMap.Terminated', 4).freeze
    Default = IctMap_Default::new('IctMap.Default', -1).freeze

end

class Ict_sm < Statemap::FSMContext

    def initialize(owner)
        super()
        @_owner = owner
        setState(IctMap::Initial)
        IctMap::Initial.Entry(self)
    end

    def cancel_sent()
        @_transition = 'cancel_sent'
        getState.cancel_sent(self)
        @_transition = nil
    end

    def invite()
        @_transition = 'invite'
        getState.invite(self)
        @_transition = nil
    end

    def non_success_final()
        @_transition = 'non_success_final'
        getState.non_success_final(self)
        @_transition = nil
    end

    def provisional()
        @_transition = 'provisional'
        getState.provisional(self)
        @_transition = nil
    end

    def success_final()
        @_transition = 'success_final'
        getState.success_final(self)
        @_transition = nil
    end

    def timer_A(*arglist)
        @_transition = 'timer_A'
        getState.timer_A(self, *arglist)
        @_transition = nil
    end

    def timer_B()
        @_transition = 'timer_B'
        getState.timer_B(self)
        @_transition = nil
    end

    def timer_D()
        @_transition = 'timer_D'
        getState.timer_D(self)
        @_transition = nil
    end

    def timer_Y()
        @_transition = 'timer_Y'
        getState.timer_Y(self)
        @_transition = nil
    end

    def transport_err()
        @_transition = 'transport_err'
        getState.transport_err(self)
        @_transition = nil
    end

    def getState()
        if @_state.nil? then
            raise Statemap::StateUndefinedException
        end
        return @_state
    end

    def getOwner()
        return @_owner
    end

end
