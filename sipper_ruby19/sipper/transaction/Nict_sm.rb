# DO NOT EDIT.
# generated by smc (http://smc.sourceforge.net/)
# from file : Nict.sm

require 'statemap'

class NictState < Statemap::State

    def Entry(fsm) end

    def Exit(fsm) end

    def final(fsm)
        Default(fsm)
    end

    def provisional(fsm)
        Default(fsm)
    end

    def request(fsm)
        Default(fsm)
    end

    def timer_E(fsm, t)
        Default(fsm)
    end

    def timer_F(fsm)
        Default(fsm)
    end

    def timer_K(fsm)
        Default(fsm)
    end

    def transport_err(fsm)
        Default(fsm)
    end

    def Default(fsm)
        msg = "\nState: " + fsm.getState.getName +
            "\nTransition: " + fsm.getTransition + "\n"
        raise Statemap::TransitionUndefinedException, msg
    end

end

class NictMap_Default < NictState

end

class NictMap_Initial < NictMap_Default

    def request(fsm)
        ctxt = fsm.getOwner
        fsm.getState.Exit(fsm)
        fsm.clearState
        begin
            ctxt.__send_request()
            ctxt.__start_E()
            ctxt.__start_F()
        ensure
            fsm.setState(NictMap::Trying)
            fsm.getState.Entry(fsm)
        end
    end

    def transport_err(fsm)
        ctxt = fsm.getOwner
        fsm.getState.Exit(fsm)
        fsm.clearState
        begin
            ctxt.__transport_err()
        ensure
            fsm.setState(NictMap::Terminated)
            fsm.getState.Entry(fsm)
        end
    end

end

class NictMap_Trying < NictMap_Default

    def final(fsm)
        ctxt = fsm.getOwner
        fsm.getState.Exit(fsm)
        fsm.clearState
        begin
            ctxt.__consume_msg(true)
        ensure
            fsm.setState(NictMap::Completed)
            fsm.getState.Entry(fsm)
        end
    end

    def provisional(fsm)
        ctxt = fsm.getOwner
        fsm.getState.Exit(fsm)
        fsm.clearState
        begin
            ctxt.__consume_msg(true)
        ensure
            fsm.setState(NictMap::Proceeding)
            fsm.getState.Entry(fsm)
        end
    end

    def timer_E(fsm, t)
        ctxt = fsm.getOwner
        endState = fsm.getState
        fsm.clearState
        begin
            ctxt.__send_request()
            ctxt.__reset_E(t)
        ensure
            fsm.setState(endState)
        end
    end

    def timer_F(fsm)
        ctxt = fsm.getOwner
        fsm.getState.Exit(fsm)
        fsm.clearState
        begin
            ctxt.__timeout()
        ensure
            fsm.setState(NictMap::Terminated)
            fsm.getState.Entry(fsm)
        end
    end

    def transport_err(fsm)
        ctxt = fsm.getOwner
        fsm.getState.Exit(fsm)
        fsm.clearState
        begin
            ctxt.__transport_err()
        ensure
            fsm.setState(NictMap::Terminated)
            fsm.getState.Entry(fsm)
        end
    end

end

class NictMap_Proceeding < NictMap_Default

    def Exit(fsm)
        ctxt = fsm.getOwner
        ctxt.__cancel_E()
        ctxt.__cancel_F()
    end

    def final(fsm)
        ctxt = fsm.getOwner
        fsm.getState.Exit(fsm)
        fsm.clearState
        begin
            ctxt.__consume_msg(true)
        ensure
            fsm.setState(NictMap::Completed)
            fsm.getState.Entry(fsm)
        end
    end

    def provisional(fsm)
        ctxt = fsm.getOwner
        endState = fsm.getState
        fsm.clearState
        begin
            ctxt.__consume_msg(true)
        ensure
            fsm.setState(endState)
        end
    end

    def timer_E(fsm, t)
        ctxt = fsm.getOwner
        endState = fsm.getState
        fsm.clearState
        begin
            ctxt.__send_request()
            ctxt.__reset_E()
        ensure
            fsm.setState(endState)
        end
    end

    def timer_F(fsm)
        ctxt = fsm.getOwner
        fsm.getState.Exit(fsm)
        fsm.clearState
        begin
            ctxt.__timeout()
        ensure
            fsm.setState(NictMap::Terminated)
            fsm.getState.Entry(fsm)
        end
    end

    def transport_err(fsm)
        ctxt = fsm.getOwner
        fsm.getState.Exit(fsm)
        fsm.clearState
        begin
            ctxt.__transport_err()
        ensure
            fsm.setState(NictMap::Terminated)
            fsm.getState.Entry(fsm)
        end
    end

end

class NictMap_Completed < NictMap_Default

    def Entry(fsm)
        ctxt = fsm.getOwner
        ctxt.__start_K()
    end

    def final(fsm)
        ctxt = fsm.getOwner
        endState = fsm.getState
        fsm.clearState
        begin
            ctxt.__consume_msg(false)
        ensure
            fsm.setState(endState)
        end
    end

    def timer_K(fsm)
        fsm.getState.Exit(fsm)
        fsm.setState(NictMap::Terminated)
        fsm.getState.Entry(fsm)
    end

end

class NictMap_Terminated < NictMap_Default

    def Entry(fsm)
        ctxt = fsm.getOwner
        ctxt.__cleanup()
    end

end

module NictMap

    Initial = NictMap_Initial::new('NictMap.Initial', 0).freeze
    Trying = NictMap_Trying::new('NictMap.Trying', 1).freeze
    Proceeding = NictMap_Proceeding::new('NictMap.Proceeding', 2).freeze
    Completed = NictMap_Completed::new('NictMap.Completed', 3).freeze
    Terminated = NictMap_Terminated::new('NictMap.Terminated', 4).freeze
    Default = NictMap_Default::new('NictMap.Default', -1).freeze

end

class Nict_sm < Statemap::FSMContext

    def initialize(owner)
        super()
        @_owner = owner
        setState(NictMap::Initial)
        NictMap::Initial.Entry(self)
    end

    def final()
        @_transition = 'final'
        getState.final(self)
        @_transition = nil
    end

    def provisional()
        @_transition = 'provisional'
        getState.provisional(self)
        @_transition = nil
    end

    def request()
        @_transition = 'request'
        getState.request(self)
        @_transition = nil
    end

    def timer_E(*arglist)
        @_transition = 'timer_E'
        getState.timer_E(self, *arglist)
        @_transition = nil
    end

    def timer_F()
        @_transition = 'timer_F'
        getState.timer_F(self)
        @_transition = nil
    end

    def timer_K()
        @_transition = 'timer_K'
        getState.timer_K(self)
        @_transition = nil
    end

    def transport_err()
        @_transition = 'transport_err'
        getState.transport_err(self)
        @_transition = nil
    end

    def getState()
        if @_state.nil? then
            raise Statemap::StateUndefinedException
        end
        return @_state
    end

    def getOwner()
        return @_owner
    end

end

